<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Go Ito">

<title>Causal Inference</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="causal_files/libs/clipboard/clipboard.min.js"></script>
<script src="causal_files/libs/quarto-html/quarto.js"></script>
<script src="causal_files/libs/quarto-html/popper.min.js"></script>
<script src="causal_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="causal_files/libs/quarto-html/anchor.min.js"></script>
<link href="causal_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="causal_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="causal_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="causal_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="causal_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Causal Inference</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Go Ito </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="to-do" class="level1">
<h1>To-Do</h1>
<ul>
<li><p>Future review</p>
<ul>
<li><p>d-separation rules</p></li>
<li><p>Fix: Sequential exchangeability - static vs.&nbsp;dynamic (take technical point 19.3 and pg257)</p></li>
<li><p>P256-257, technical point 19.3 vs.&nbsp;dynamic 1, why (Y,L)\perp A vs.&nbsp;Y\perp A? Why one includes L in a joint format while the other doesn’t for exchangeability under dynamic strategy?</p></li>
<li><p>S&amp;D3, why <span class="math inline">\(A\leftarrow L \rightarrow Y\)</span> would make SWIG to not hold conditional exchangeability? Same for D2 - check d-separation</p></li>
</ul></li>
<li><p>Skim read headers of Ch20 - 22 sections, set expectations and write down ideas</p></li>
<li><p>Decide a temporal switch to network x causal</p></li>
</ul>
<section id="library" class="level2">
<h2 class="anchored" data-anchor-id="library">Library</h2>
</section>
<section id="resource" class="level2">
<h2 class="anchored" data-anchor-id="resource">Resource</h2>
<ul>
<li><a href="http://miguelhernan.org/whatifbook" class="uri">http://miguelhernan.org/whatifbook</a></li>
</ul>
</section>
</section>
<section id="study-notes" class="level1">
<h1>Study Notes</h1>
<section id="causal-inference-in-complex-systems-with-network-interference-and-temporal-dynamics" class="level3">
<h3 class="anchored" data-anchor-id="causal-inference-in-complex-systems-with-network-interference-and-temporal-dynamics">Causal Inference in Complex Systems with Network Interference and Temporal Dynamics</h3>
<p>Resource:</p>
<ul>
<li><a href="https://www.sigmetrics.org/sigmetrics2024/tutorials/2024_06_10_SIGMETRICS_tutorial.pdf" class="uri">https://www.sigmetrics.org/sigmetrics2024/tutorials/2024_06_10_SIGMETRICS_tutorial.pdf</a></li>
</ul>
<section id="introduction" class="level4">
<h4 class="anchored" data-anchor-id="introduction">Introduction</h4>
<ul>
<li><p>SUTVA - unit i’s outcome don’t affect j’s</p></li>
<li><p>Network intference - study Total Treatment Effect / Global Average Treatment Effect (GATE) - all treated - no one treated</p></li>
<li><p>Exposure Mapping - ?</p></li>
<li><p>Network Interference Challenge - TTE biased</p></li>
</ul>
</section>
<section id="interference" class="level4">
<h4 class="anchored" data-anchor-id="interference">Interference</h4>
<ul>
<li><p>Temporal Interference - interference path can be represented as a sequential line graph, from t-1 to t, t to t+1 etc.</p></li>
<li><p>Markovian Interference - temporal dependence + states</p>
<ul>
<li><span class="math inline">\(Y_t\)</span> is a function of the state <span class="math inline">\(X_t\)</span>, affected by treatment <span class="math inline">\(Z_t\)</span> and state <span class="math inline">\(X_{t-1}\)</span></li>
</ul></li>
</ul>
<p><img src="images/clipboard-3685820932.png" class="img-fluid" width="498"></p>
<ul>
<li><p>Spatio-temporal Interference</p></li>
<li><p>Estimate potential outcome of Z’ from Z - model (with strong assumption) vs.&nbsp;experimentation (to mitigate assumptions)</p></li>
</ul>
</section>
<section id="design-of-experiment" class="level4">
<h4 class="anchored" data-anchor-id="design-of-experiment">Design of Experiment</h4>
<p><strong>Outline</strong></p>
<ul>
<li><p>Randomized Design - distribution for assigning treatment/control</p>
<ul>
<li><p>Choose treatment assignments by a known randomization rule (possibly graph-aware) and estimate effects using that randomization.</p></li>
<li><p>Trust the design, not a model - validity comes from <span class="math inline">\(P(Z)\)</span>, treating outcomes as fixed under the design.</p></li>
<li><p>Cluster-based randomized designs that exploit <strong>graph structure</strong></p></li>
<li><p>Use application specific structure to reduce bias via experimental design</p></li>
</ul></li>
<li><p>Model based Estimator - method to process data collected from experiment</p>
<ul>
<li><p>Specify a probabilistic outcome + network dependence/interference model and design/estimate under that model (likelihood/Bayes).</p></li>
<li><p>Trust the model - learn effects by fitting a structured data-generating process.</p></li>
<li><p>Use regression to exploit <strong>structure in the potential outcomes model</strong></p></li>
<li><p>Use application specific structure to construct estimator</p></li>
</ul></li>
<li><p>Experiments over time - richer measurements, complex dynamics</p></li>
<li><p>Model-assisted randomized</p>
<ul>
<li><p>Use a model to pick a good randomization scheme, but do inference with design-based guarantees.</p></li>
<li><p>Model for planning, randomization for credibility.</p></li>
</ul></li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li><p>Scenario:</p>
<ul>
<li><p>You’re launching a new “AI summarization” feature in an app. Users are connected by a follow/friend graph.</p></li>
<li><p>Outcome: Y - weekly retention</p></li>
<li><p>Interference: ’if my friends get the feature, they talk about it / share clips → affects me.</p></li>
</ul></li>
<li><p><strong>Randomized Network Design</strong></p>
<ul>
<li><p>Goal: credible ATE/spillover claims with minimal modeling assumptions.</p></li>
<li><p>Implementation: Graph-cluster randomization- Partition the user graph into clusters (e.g., via METIS / spectral partition) to minimize edges across clusters. Then, <strong>randomize clusters to treatment/control</strong> (or randomize cluster “saturation” rates).</p></li>
<li><p>When you <strong>don’t know (or don’t trust) the network spillover mechanism</strong>, you randomize using a credible rule (often with clustering/restrictions) and let the known assignment probabilities—not a model—carry the causal validity.</p></li>
<li><p>Source of noise: Assignment itself - treat potential outcomes as fixed facts, and the random pull was the source of noise - “we happened to treat a weird subset this time.”</p></li>
</ul></li>
</ul>
<!-- -->
<ul>
<li><p><strong>Model-based Network Design</strong></p>
<ul>
<li><p>Goal: maximum efficiency + mechanism (but you must be right-ish about the mwell, odel).</p></li>
<li><p>Implementation: Assume <strong>a spillover model</strong>, e.g.&nbsp;linear-in-means. Design treatment assignment strategy such that optimize some goal e.g.&nbsp;choose Z to maximize information or minimize estimation error etc.</p></li>
<li><p>When you’re <strong>willing to assume a specific interference/spillover model</strong> (or distributional structure), you fit that model to estimate the treatment effect more efficiently—at the cost of being wrong if the model is wrong.</p></li>
<li><p>Source of noise: outcome-generating randomness <span class="math inline">\(\epsilon\)</span> of <span class="math inline">\(Y=a+\beta Z + \epsilon\)</span>, so model estimates the both outcomes (treated/control) - “even for the same treatment, outcomes are noisy draws from a probabilistic world (plus model misspecification risk).”</p></li>
</ul></li>
</ul>
<!-- -->
<ul>
<li><p><strong>Model-assisted Randomized Design</strong></p>
<ul>
<li><p>Goal: keep design-based credibility, but use a model to avoid dumb randomizations.</p></li>
<li><p>Implementation: Use a model/simulation only to choose the randomization scheme (Pick the design that minimizes predicted variance / improves exposure balance), Run the chosen randomized design (still a known <span class="math inline">\(P(Z)\)</span>), Analyze design-based (HT/IPW + randomization inference), optionally add regression adjustment for variance reduction.</p></li>
<li><p>When you know <strong>enough structure to plan smart randomization</strong> (clusters/saturation/restrictions) but don’t want to bet inference on the model, you use the model for design and randomization for validity.</p></li>
<li><p>Difference with #1: Does your choice of randomization depend on a predictive/working model of outcomes/interference (for efficiency) - #3, or is the model only used to define the estimand/exposure and the inference stays valid without it? - #1</p></li>
<li><p>Source of noise: For inference, the noise is still the randomization/sampling mechanism like randomization-based. But, the model adds a planning layer, not an inference layer: It’s used to choose a design that will likely have lower variance / better exposure balance. If the model is wrong, what changes is efficiency/power, not the validity of the uncertainty calculation—as long as you still know/track the true assignment probabilities.</p></li>
</ul></li>
</ul>
<p><strong>Horvitz-Thompson Estimator</strong></p>
<ul>
<li><p><span class="math inline">\(\hat{\tau}=\frac{1}{N}\sum^N_{i=1}Y_i\left\{ \frac{Z_i}{P(Z_i=1)} - \frac{1-Z_i}{P(Z_i=0)} \right\}\)</span></p></li>
<li><p>A general unequal-probability sampling estimator, not just for experiment</p></li>
<li><p>For the average treatment effect <span class="math inline">\(\tau = \frac{1}{N}\sum^N_{i=1}Y_i(1) - Y_i(0)\)</span></p></li>
<li><p>Probability denominator - IPTW, so blow up when P of either are so small / unbalanced</p>
<ul>
<li>Show this by upperbound</li>
</ul></li>
</ul>
<p><img src="images/clipboard-1386835465.png" class="img-fluid" width="489"></p>
<p><strong>Partial Interference</strong></p>
<ul>
<li><p>Partial interference is the assumption that interference exists, but only within pre-defined groups, and does not cross groups; Units can affect each other’s outcomes inside the same cluster/block, but units in different clusters don’t affect each other. Achieve low variance for HT-estimator</p></li>
<li><p>Literature consider - varying treatment fraction to estimate finer estimands beyond TTE; consider observational data</p></li>
</ul>
<p><strong>Cluster Randomized Design</strong></p>
<ul>
<li><p>3-net clustering for restricted-growth graphs - achieve low variance</p></li>
<li><p>Computationally heavy to implement designs &amp; probabilities</p></li>
<li><p>Construct clusters with probability of <span class="math inline">\(1/d^2\)</span> (degree) for all its neighbors to be in the same cluster, so as sample size increase, as does the number of clusters</p></li>
<li><p>Give treatment at cluster-unit</p></li>
</ul>
<p>Spatial Interference ############## continue next, 2026/02/08</p>
<p>Model-based Interference</p>
<p><strong>Confounding due to Network Interference</strong></p>
<ul>
<li><p>Network can introduce confounding (additional path from unobserved confounder)</p></li>
<li><p>Nodes with more degree = high chance of the nodes are treated = more path for confounder</p></li>
<li><p>Linear-in-Mean Models - relies on <span class="math inline">\(\phi\)</span> to be correct function</p></li>
</ul>
<p><img src="images/clipboard-2412392172.png" class="img-fluid" width="490"></p>
<p>Neighborhood Interference</p>
<ul>
<li>Potential outcome is only a function of neighborhood treatment</li>
</ul>
<p>Low Order Interactions</p>
<ul>
<li>if network effects are additive across subcommunities, then degree would be at most size of largest subcommunity</li>
</ul>
<p>Heterogeneous Additive Network Effects</p>
<p>Pseudoinverse Estimator</p>
<p><strong>Experiments across Time</strong></p>
<ul>
<li><strong>Staggered Rollout Bernoulli Design + TTE</strong></li>
</ul>
<p><strong>Design and Analysis of Switchback Experiments</strong></p>
<ul>
<li><p><strong>Cluster RD on a line graph</strong></p></li>
<li><p>Markovian Dynamics + Geometric Mixing</p></li>
</ul>
<p><strong>Paper to Read</strong></p>
<ul>
<li><p>Christina Lee Yu, Edo Airoldi, Christian Borgs, and Jennifer Chayes. “Estimating Total Treatment Effect in Randomized Experiments with Unknown Network Structure”. PNAS, 2022.</p></li>
<li><p>Mayleen Cortez-Rodriguez, Matthew Eichhorn, Christina Lee Yu. “Staggered Rollout Designs Enable Causal Inference Under Interference Without Network Knowledge.” Neurips, 2022.</p></li>
<li><p>Anish Agarwal, Sarah H. Cen, Devavrat Shah, Christina Lee Yu. “Network Synthetic Interventions: A Causal Framework for Panel Data Under Network Interference.” Arxiv:2210.11355, 2024.</p></li>
<li><p>Iavor Bojinov, David Simchi-Levi, Jinglong Zhao. “Design and Analysis of Switchback Experiments”. Management Science, 2022</p></li>
<li><p>Yuchen Hu, Stefan Wager - “Switchback Experiments under Geometric Mixing”</p></li>
<li><p>Su Jia, Nathan Kallus, Christina Lee Yu. “Clustered Switchback Experiments: Near-Optimal Rates Under Spatiotemporal Interference”</p></li>
</ul>
<!-- -->
<ul>
<li></li>
</ul>
<p>Thoughts</p>
<ul>
<li><p>Time dimension as network graph, so dynamic network as fully graph?</p>
<ul>
<li>Markovian dynamics + geometric mixing?</li>
</ul></li>
<li><p>Staggered roll out design?</p></li>
<li><p>Generalized graph design?</p></li>
</ul>
<p>Edo - Christina Yu?</p>
</section>
</section>
</section>
<section id="causal-inference-without-models" class="level1">
<h1>Causal Inference without Models</h1>
<section id="basicsnotes" class="level2">
<h2 class="anchored" data-anchor-id="basicsnotes">Basics/Notes</h2>
<section id="difference-between-a-and-a" class="level3">
<h3 class="anchored" data-anchor-id="difference-between-a-and-a">Difference between A and a</h3>
<ul>
<li><p><span class="math inline">\(A\)</span> : random variable. A very typical predictor (or column in a dataset) to an outcome <span class="math inline">\(Y\)</span> to any model that can be considered without a causal framework. In a DAG framework with a measured covariate <span class="math inline">\(L\)</span> and an outcome <span class="math inline">\(Y\)</span>, they coincide as conditional independence, not a causal semantics. However, when you declare the DAG “causal” and thus assume each node (variables) is generated by a structural equation, do-calculus now have meaning and override the equation for <span class="math inline">\(A\)</span> and set <span class="math inline">\(A=a\)</span> .</p></li>
<li><p><span class="math inline">\(a\)</span>: has two meanings, and they coincide only under <strong>consistency</strong> assumption.</p>
<ul>
<li><p><strong>Factual value</strong> - the realized treatment value naturally happened to be that number i.e., just a value in a column <span class="math inline">\(A\)</span> in observational study, <span class="math inline">\(P(Y|A=a, L)\)</span></p></li>
<li><p><strong>Interventional value</strong> - the value you impose in a experimental world, <span class="math inline">\(E[Y^a],\quad P(Y|\text{do}(A=a))\)</span></p></li>
</ul></li>
</ul>
</section>
</section>
<section id="confounding" class="level2">
<h2 class="anchored" data-anchor-id="confounding">Confounding</h2>
<section id="d-separaration" class="level3">
<h3 class="anchored" data-anchor-id="d-separaration">d-Separaration</h3>
<p>aaa</p>
</section>
<section id="single-world-intervention-graphs-swig" class="level3">
<h3 class="anchored" data-anchor-id="single-world-intervention-graphs-swig">Single-World Intervention Graphs (SWIG)</h3>
<p>Potential outcome framework is not encapsulated in causal diagrams as-is. Single world intervention graphs (SWIG) unifies counterfactual and graphical approaches by explicitly including the counterfactual variables on the graph. The <strong>SWIG 1</strong> shows that the equivalence of conditional exchangeability <span class="math inline">\(Y^a\perp A|L\)</span> and the backdoor criterion (with all path blocked between <span class="math inline">\(Y^a\)</span> and <span class="math inline">\(A\)</span> after conditioning on <span class="math inline">\(L\)</span>), whereas <strong>SWIG 2</strong> also visually shows the exchangeability <span class="math inline">\(Y^a\perp A|L\)</span> would NOT hold, and conditioning (blocking) on <span class="math inline">\(L\)</span> would lead to a biased estimate.</p>
<p><strong>DAG 1</strong></p>
<p><img src="images/clipboard-97384580.png" class="img-fluid"></p>
<p><strong>SWIG 1</strong></p>
<p><img src="images/clipboard-3938487221.png" class="img-fluid"></p>
<p><strong>DAG 2</strong></p>
<p><img src="images/clipboard-1367899619.png" class="img-fluid"></p>
<p><strong>SWIG 2</strong></p>
<p><img src="images/clipboard-2296119913.png" class="img-fluid"></p>
</section>
</section>
</section>
<section id="time-varying-causal-inference" class="level1">
<h1>Time-Varying Causal Inference</h1>
<section id="time-varying-treatment" class="level2">
<h2 class="anchored" data-anchor-id="time-varying-treatment">Time-Varying Treatment</h2>
<section id="definition-of-causal-effects-on-time" class="level3">
<h3 class="anchored" data-anchor-id="definition-of-causal-effects-on-time">Definition of Causal Effects on Time</h3>
<p><strong>Time-fixed Treatment:</strong> Only captures the average causal effect in a snapshot.</p>
<p><span class="math display">\[
E[Y^{a=1}] - E[Y^{a=0}]
\]</span></p>
<p><strong>Time-varying Treatment:</strong> A person can switch treatment over time, with a treatment history <span class="math inline">\(\bar{A} = (a_0, a_1,\dots,a_K)\)</span> for <span class="math inline">\(0\leq k \leq K\)</span>. Suppose that <span class="math inline">\(Y\)</span> is the outcome at the end of follow-up <span class="math inline">\(\bar{A}\)</span>, at time <span class="math inline">\(K+1\)</span>. We can no longer define the average causal effect of at a single time <span class="math inline">\(k\)</span> only i.e., <span class="math inline">\(E[Y^{a_k=1}] - E[Y^{a_k=0}]\)</span>. We define average causal effect as a contrast between the counterfactual mean outcomes under two different series of treatment strategies <span class="math inline">\(\bar{A}\)</span> and <span class="math inline">\(\bar{A}'\)</span> at all time (0 to K) <span class="math inline">\(E[Y^{\bar{a}}] - E[Y^{\bar{a}'}]\)</span>. Thus, the definition of this ACE of a time-varying treatment is not uniquely defined.</p>
<hr>
</section>
<section id="treatment-strategy" class="level3">
<h3 class="anchored" data-anchor-id="treatment-strategy">Treatment Strategy</h3>
<p>Treatment strategy <span class="math inline">\(g\)</span> is a rule to assign treatment at each time <span class="math inline">\(k\)</span> of follow-up. There are many possible treatment strategies that may or may not depend on the evolution of an individual’s treatment history or time-varying covariate(s) <span class="math inline">\(\bar{L}_k\)</span>. These could be considered (but not limited to) as the combination of the following two ideas:</p>
<section id="deterministic-vs.-random-treatment-strategies" class="level4">
<h4 class="anchored" data-anchor-id="deterministic-vs.-random-treatment-strategies">Deterministic vs.&nbsp;Random Treatment Strategies</h4>
<ul>
<li><p><strong>Deterministic Treatment Strategies</strong>: A rule that assign a particular value of treatment <span class="math inline">\(a_k\)</span> (0 or 1) to each individual at each time.</p></li>
<li><p><strong>Random Treatment Strategies</strong>: A rule that assign a probability of receiving a treatment value.</p></li>
</ul>
</section>
<section id="statics-vs.-dynamic-treatment-strategies" class="level4">
<h4 class="anchored" data-anchor-id="statics-vs.-dynamic-treatment-strategies">Statics vs.&nbsp;Dynamic Treatment Strategies</h4>
<ul>
<li><p><strong>Static Treatment Strategies:</strong> A rule <span class="math inline">\(g = [g_0(\bar{a}_{-1}), \dots, g_0(\bar{a}_{K-1})]\)</span> where <span class="math inline">\(g_k(\bar{a}_{k-1})\)</span> depends on its past treatment history but does not depend on time-varying covariate(s) <span class="math inline">\(\bar{l}_k\)</span>. Examples:</p>
<ul>
<li><p>“always treat”: <span class="math inline">\(\bar{a} = (1,1,\dots,1) = \bar{1}\)</span></p></li>
<li><p>“never treat”: <span class="math inline">\(\bar{a} = (0,0,\dots,0) = \bar{0}\)</span></p></li>
</ul></li>
<li><p><strong>Dynamic Treatment Strategies:</strong> A rule <span class="math inline">\(g = [g_0(\bar{a}_{-1}, l_{0}), \dots, g_0(\bar{a}_{K-1}, \bar{l}_{K})]\)</span> where <span class="math inline">\(g_k(\bar{a}_{k-1}, \bar{l}_k)\)</span> depends on both its past treatment history and time-varying covariate(s) <span class="math inline">\(\bar{l}_k\)</span> at each time <span class="math inline">\(k\)</span>.</p>
<ul>
<li>Dynamic treatment strategy can also be denoted as a recursion of its past <span class="math inline">\(g\)</span> , a dynamic strategy <span class="math inline">\(g' = [g'_0(\bar{l}_0),\dots,g'_K(\bar{l}_K)]\)</span>, where <span class="math inline">\(g'_k(\bar{l}_k) = g_{k}(g'_{k}(\bar{l}_{k-1}), \bar{l}_{k})\)</span> with <span class="math inline">\(g'_0(\bar{l}_{0}) = g_{0}(a'_{-1}=0,\bar{l}_{0})\)</span>. This definition of <span class="math inline">\(g'\)</span> guarantees that an individual has followed strategy <span class="math inline">\(g\)</span> through time <span class="math inline">\(t\)</span> in observed data i.e., <span class="math inline">\(A_{k} = g_k (\bar{A}_{k-1}, \bar{L}_k)\)</span> for <span class="math inline">\(k\leq t\)</span>, if and only if the individual has followed strategy <span class="math inline">\(g'\)</span> through time <span class="math inline">\(t\)</span> in observed data i.e., <span class="math inline">\(A_{k} = g_k' (\bar{L}_k)\)</span> for <span class="math inline">\(k\leq t\)</span>.</li>
</ul></li>
</ul>
</section>
<section id="optimal-treatment-strategy" class="level4">
<h4 class="anchored" data-anchor-id="optimal-treatment-strategy">Optimal Treatment Strategy</h4>
<p>A strategy <span class="math inline">\(g\)</span> maximizes the mean counterfactual outcome <span class="math inline">\(E[Y^g]\)</span> (in a positive direction) is referred as <strong>optimal treatment strategy</strong>. In practice, optimal treatment strategies are almost always dynamic (e.g., discontinue drug testing by poison-level, spread marketing on seasonal peak) and often be preferred over random strategy (optimization vs.&nbsp;randomization). However, random strategy (randomized trial) is scientifically important to identify which deterministic strategy is optimal.</p>
<hr>
</section>
</section>
<section id="sequentially-randomized-experiment" class="level3">
<h3 class="anchored" data-anchor-id="sequentially-randomized-experiment">Sequentially Randomized Experiment</h3>
<p>An experiment in which treatment assignment <span class="math inline">\(A_k\)</span> is random at each time <span class="math inline">\(k\)</span> to each individual is referred to as <strong>sequentially randomized experiment (SRE)</strong>. It can be represented by a causal diagram at time points <span class="math inline">\(k = 0, 1, \dots, K\)</span> and with no direct arrows from unmeasured prognostic factors / covariate(s) <span class="math inline">\(U\)</span> into treatment <span class="math inline">\(A_k\)</span> at any time <span class="math inline">\(k\)</span>.</p>
<p><strong>Key Point:</strong> Assuming that a treatment assignment <span class="math inline">\(A_k\)</span> at each time <span class="math inline">\(k\)</span> depends on its past treatment history by default</p>
<ul>
<li><p><strong>Case 1</strong>: A treatment assignment <span class="math inline">\(A _k\)</span> with NO dependence on unmeasured covariate(s) <span class="math inline">\(\bar{U}_k\)</span> and measured covariate(s) <span class="math inline">\(\bar{L}_k\)</span> <span class="math inline">\(\Rightarrow\)</span> <strong>SRE</strong></p>
<ul>
<li>Static treatment strategy under this scenario yields the counterfactual outcome mean equal to the mean outcome <span class="math inline">\(E[Y^{\bar{a}}] = E[Y|\bar{A}={\bar{a}}]\)</span>. This is not true for dynamic treatment strategy <span class="math inline">\(g\)</span>, and the estimation of <span class="math inline">\(E[Y^g]\)</span> would require the application of <strong>g-methods</strong>.</li>
</ul></li>
</ul>
<p><img src="images/clipboard-1409898166.png" class="img-fluid"></p>
<ul>
<li><strong>Case 2</strong>: A treatment assignment <span class="math inline">\(A _k\)</span> with NO dependence on unmeasured covariate(s) <span class="math inline">\(\bar{U}_k\)</span> BUT with dependence on measured covariate(s) <span class="math inline">\(\bar{L}_k\)</span> <span class="math inline">\(\Rightarrow\)</span> <strong>SRE</strong></li>
</ul>
<p><img src="images/clipboard-2970662127.png" class="img-fluid"></p>
<ul>
<li><strong>Case 3</strong>: A treatment assignment <span class="math inline">\(A _k\)</span> with dependence on unmeasured covariate(s) <span class="math inline">\(\bar{U}_k\)</span> <span class="math inline">\(\Rightarrow\)</span> <strong>not SRE</strong>, one cannot correctly assign treatment randomly with a guarantee</li>
</ul>
<p><img src="images/clipboard-1129067845.png" class="img-fluid"></p>
<section id="observational-study" class="level4">
<h4 class="anchored" data-anchor-id="observational-study">Observational Study</h4>
<p>For observational study, <strong>Case 2</strong> and <strong>Case 3</strong> are the most typical scenarios given the nature of decisions about treatment assignment <span class="math inline">\(A_k\)</span> often being determined by prognostic factors. However, it is impossible to determine weather it is <strong>Case 2</strong> or <strong>Case 3</strong>.</p>
<p>For <strong>Case 2</strong>, the main difference against SRE is that the assignment probabilities are unknown but estimable from data.</p>
<hr>
</section>
</section>
<section id="sequential-identifiability---exchangeability-positivity-and-consistency" class="level3">
<h3 class="anchored" data-anchor-id="sequential-identifiability---exchangeability-positivity-and-consistency">Sequential Identifiability - Exchangeability, Positivity, and Consistency</h3>
<p>Under the three identifiability conditions - exchangeability, positivity, and consistency - we can identify the mean counterfactual outcome <span class="math inline">\(E[Y^g]\)</span> under a strategy of interest <span class="math inline">\(g\)</span> as long as we use methods that approproately adjust for treatment and covariate history <span class="math inline">\((\bar{A}_{k-1}, \bar{L}_{k})\)</span> such as g-formula, IPW, g-estimation (next chapter). All three conditions need to be generalized from the fixed version to the sequential version, including both static and dynamic strategies.</p>
<section id="sequential-exchangeability" class="level4">
<h4 class="anchored" data-anchor-id="sequential-exchangeability">Sequential Exchangeability</h4>
<p>For any strategy <span class="math inline">\(g\)</span>, treated and untreated at each time <span class="math inline">\(k\)</span> are exchangeable for <span class="math inline">\(Y^g\)</span> conditional on prior covariate history <span class="math inline">\(\bar{L}_k\)</span> and any observed treatment history <span class="math inline">\(\bar{A}_{k-1} = g(\bar{A}_{k-2}, \bar{L}_{k-1})\)</span> compatible with <span class="math inline">\(g\)</span>. One formal definition:</p>
<p><span class="math display">\[
Y^g \perp A_k|\bar{A}_{k-1} = g(\bar{A}_{k-2}, \bar{L}_{k-1}), \bar{L}_{k} \text{ for all strategies } g \text{ and } k = 1,2,\dots,K
\]</span></p>
<p>This form of sequential exchangeability for <span class="math inline">\(Y^g\)</span> always hold for cases (such as <strong>Case 2</strong>) with no unmeasured covariate(s) <span class="math inline">\(\bar {U}_k\)</span>affecting the treatment and measured covariate history <span class="math inline">\((\bar{A}_{k-1}, \bar{L}_{k})\)</span>. Thus, sequential exchangeability holds for sequential randomized experiment and observational study, and their mean of the counterfactual outcome <span class="math inline">\(E[Y^g]\)</span> under all strategies <span class="math inline">\(g\)</span> is identified.</p>
<p>For cases other than <strong>Case 2</strong>, mean counterfactual outcome <span class="math inline">\(E[Y^g]\)</span> under for some but not all strategies <span class="math inline">\(g\)</span> is identifiable, even with a presense of additional unmeasured covariate(s) <span class="math inline">\(\bar{W}\)</span>. In the example <strong>Case 4</strong> below with <span class="math inline">\(W_0\)</span> not directly affecting the immediate treatment <span class="math inline">\(A_1\)</span> to <span class="math inline">\(Y\)</span>, the mean counterfactual outcome <span class="math inline">\(E[Y^g]\)</span> is identifiable with static strategy but not with dynamic strategy (will follow up on this later with SWIGs).</p>
<p><img src="images/clipboard-518200905.png" class="img-fluid"></p>
</section>
<section id="sequential-positivity" class="level4">
<h4 class="anchored" data-anchor-id="sequential-positivity">Sequential Positivity</h4>
<p>In SRE, positivity holds if the randomization probabilities at each time <span class="math inline">\(k\)</span> are never either 0 or 1, regardless of the past history <span class="math inline">\((\bar{A}_{k-1}, \bar{L}_{k})\)</span>. That is, as long as <span class="math inline">\(\bar{A}_{k-1} \not\perp \bar{L}_{k}\)</span>, then the treatment assignment probability for <span class="math inline">\(A_k\)</span> at <span class="math inline">\(k\)</span> is not 0.</p>
<p><span class="math display">\[
\text{If } f_{\bar{A}_{k-1}, \bar{L}_k}(\bar{a}_{k-1}, \bar{l}_k) \neq 0
\text{, then }
f_{A_k|\bar{A}_{k-1}, \bar{L}_k}(\bar{a}_{k-1}, \bar{l}_k) &gt; 0
\:\forall(\bar{a}_{k-1}, \bar{l}_k)
\]</span></p>
</section>
<section id="sequential-consistency-need-review" class="level4">
<h4 class="anchored" data-anchor-id="sequential-consistency-need-review">Sequential Consistency [NEED REVIEW]</h4>
<p>We define sequential consistency with dependence to the past history.</p>
<p><span class="math display">\[\begin{align}
Y^{\bar{a}} = Y^{\bar{a}^*} &amp;\text{ if }\:\bar{a}=\bar{a}^*&amp;&amp;
\cdots\text{outcome is identical under the same strategies}\\
Y = Y^{\bar{a}} &amp;\text{ if }\:\bar{A}=\bar{a}&amp;&amp;
\cdots\text{outcome is consistent under the same treatment history}\\
\bar{L}^{\bar{a}}_{k} = \bar{L}^{\bar{a}^*}_{k} &amp;\text{ if }\: \bar{a}_{k-1}=\bar{a}_{k-1}^*&amp;&amp;
\cdots\text{covariate history through k are identical under the same strategies}\\
\bar{L}_{k} = \bar{L}^{\bar{a}}_{k} &amp;\text{ if }\: \bar{A}_{k-1}=\bar{a}_{k-1}&amp;&amp;
\cdots\text{covariate history through k are consistent under the same treatment history}
\end{align}\]</span></p>
<p>where <span class="math inline">\(\bar{L}^{\bar{a}}_{k}\)</span> is the counterfactual L-history through time <span class="math inline">\(k\)</span> under strategy <span class="math inline">\(\bar{a}\)</span>.</p>
<hr>
</section>
</section>
<section id="single-world-intervention-graphs-swig-on-time-varying-treatment-various-form-of-exchangeability" class="level3">
<h3 class="anchored" data-anchor-id="single-world-intervention-graphs-swig-on-time-varying-treatment-various-form-of-exchangeability">Single-World Intervention Graphs (SWIG) on Time-Varying Treatment; Various Form of Exchangeability</h3>
<p>Similar to time-fixed cases, we can use SWIG to represent time-varying treatment. SWIGs include the counterfactual outcome, which means we can visually verify exchangeability using d-separation.</p>
<p>With SWIG, we can also verify that conditions for exchangeability to hold vary by 1. presence of various unmeasured covariate(s) 2. static strategy vs.&nbsp;dynamic strategy.</p>
<p><strong>Case 1:</strong> Unmeasured covariate <span class="math inline">\(L_1\leftarrow U_1 \rightarrow Y\)</span> - exchangeability holds for static strategy and dynamic strategy.</p>
<p><img src="images/clipboard-4235513200.png" class="img-fluid"></p>
<p><strong>SWIG (static) 1:</strong> Two conditional independence hold: <span class="math inline">\(Y^{a_0, a_1}\perp A_0\)</span> and <span class="math inline">\(Y^{a_0, a_1}\perp A_1|A_0=a_0, L_1\)</span> for any static strategy <span class="math inline">\((a_0, a_1)\)</span>. More generally, below <strong>static sequential exchangeability</strong> hold. This is a weaker condition given that it only requires conditional independence between counterfactual outcome <span class="math inline">\(Y^{\bar{a}}\)</span> under any static strategy <span class="math inline">\(g=\bar{a}\)</span>.</p>
<p><span class="math display">\[
Y^{\bar{a}}\perp A_k|\bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k\quad\text{for }k=1,\dots,K
\]</span></p>
<p>As we consider multiple points <span class="math inline">\(k=0,\dots,K\)</span>, a stronger version of static sequential exchangeability includes <span class="math inline">\(\underline{L}^{\bar{a}}_{k+1}\)</span>, the counterfactual covariate history from time <span class="math inline">\(k+1\)</span> through the end of follow-up. With consistency assumption, that would be:</p>
<p><span class="math display">\[
(Y^{\bar{a}}, \underline{L}^{\bar{a}}_{k+1})\perp A_k|\bar{A}_{k-1} = \bar{a}_{k-1}, \bar{L}_k\quad\text{for }k=1,\dots,K
\]</span></p>
<p>Assume a version of below SWIG where there is an additional arrow from <span class="math inline">\(U_1\)</span> to <span class="math inline">\(A^{a_0}_1\)</span>. With this case, no form of sequential exchangeability would hold.</p>
<p><img src="images/clipboard-179046077.png" class="img-fluid"></p>
<p><strong>SWIG (dynamic) 1:</strong> The SWIG includes a dotted arrow <span class="math inline">\(L^{g}_1 \rightarrow g_1(L^g_1)\)</span>, because we are assuming a counterfactual world associated with a dynamic strategy. Thus, we need to draw this arrow differently from others, even though we still treat is like other arrows when evaluating d-separation. Applying d-separation to this SWIG, two conditional independence hold: <span class="math inline">\(Y^{g}\perp A_0\)</span> and <span class="math inline">\(Y^{g}\perp A_1|A_0=g_0, L_1\)</span> for any dynamic strategy <span class="math inline">\(g\)</span>.</p>
<p>However as we consider multiple points <span class="math inline">\(k=0,\dots,K\)</span>, we need to include <span class="math inline">\(\underline{L}^, {\bar{a}}_{k+1}\)</span>the counterfactual covariate history from time <span class="math inline">\(k+1\)</span> through the end of follow-up as below.</p>
<p><span class="math display">\[
(Y^{g}, \underline{L}^{g}_{k+1})\perp A_k|\bar{A}_{k-1} = g(\bar{A}_{k-1}, \bar{L}_k), \bar{L}_k\quad\text{for }k=1,\dots,K\text{ and all } g
\]</span></p>
<p>If positivity holds, this is sufficient to identify the outcome and covariate distribution under any static and dynamic strategies <span class="math inline">\(g\)</span>. For dynamic strategies, separate independence on <span class="math inline">\(Y^g\)</span> and <span class="math inline">\(\underline{L}^{\bar{a}}_{k+1}\)</span> does not hold <strong>[NEED DEEPER REVIEW WHY IN COMPARISON TO ABOVE STATEMENT]</strong>.</p>
<p><img src="images/clipboard-1803475518.png" class="img-fluid"></p>
<p><strong>Case 2:</strong> Unmeasured covariate <span class="math inline">\(A_0\leftarrow W_0 \rightarrow L1\)</span> - exchangeability holds for static strategy but NOT dynamic strategy.</p>
<p><img src="images/clipboard-2832821692.png" class="img-fluid"></p>
<p><strong>SWIG (static) 2:</strong> Even with an unmeasured covariate <span class="math inline">\(W_0\)</span>, two conditional exchangeabilities <span class="math inline">\(Y^{a_0, a_1}\perp A_0\)</span> and <span class="math inline">\(Y^{a_0, a_1}\perp A_1|A_0=a_0, L_1\)</span> for any static strategy <span class="math inline">\((a_0, a_1)\)</span> still hold by applying d-separation.</p>
<p><img src="images/clipboard-400085540.png" class="img-fluid"></p>
<p><strong>SWIG (dynamic) 2:</strong> By applying d-separation, <span class="math inline">\(Y^g\perp A_0\)</span> does not hold because of the open path <span class="math inline">\(A_0\leftarrow W_0\rightarrow L^g_1 \rightarrow g_1(L^g_1)\rightarrow Y^g\)</span>. Thus, sequential exchangeability for <span class="math inline">\(Y^g\)</span> does not hold.</p>
<p><img src="images/clipboard-1436239050.png" class="img-fluid"></p>
<p><strong>Case 3:</strong> Using d-separation, it shows that neither static sequential exchangeability <span class="math inline">\(Y^{\bar{a}}\)</span> nor dynamic sequential exchangeability <span class="math inline">\(Y^g\)</span> hold, because of open path <span class="math inline">\(A_0\leftarrow W_0 \rightarrow L_1 \rightarrow Y\)</span>, and thus, we cannot estimate causal effects in this scenario involving any strategies.</p>
<p><img src="images/clipboard-2262166617.png" class="img-fluid"></p>
<p><img src="images/clipboard-3635992770.png" class="img-fluid"></p>
<section id="full-sequential-exchangeability" class="level4">
<h4 class="anchored" data-anchor-id="full-sequential-exchangeability">Full Sequential Exchangeability</h4>
<p>A strong condition that is expected to hold in sequentially randomized experiment is</p>
<p><span class="math display">\[
(Y^{\bar{\mathcal{A}}}, \bar{L}^{\bar{\mathcal{A}}})\perp A_k|\bar{A}_{k-1}, \bar{L}_k
\]</span></p>
<p>where, for a dichotomous treatment <span class="math inline">\(A_k\)</span>, <span class="math inline">\(\bar{\mathcal{A}}\)</span> denotes the set of all <span class="math inline">\(2^K\)</span> static strategies <span class="math inline">\(\bar{a}\)</span>, <span class="math inline">\(Y^{\bar{\mathcal{A}}}\)</span> denotes the set of all counterfactual outcomes <span class="math inline">\(Y^{\bar{a}}\)</span>, and <span class="math inline">\(\bar{L}^{\bar{\mathcal{A}}}\)</span> denotes the set of all counterfactual covariate histories. This joint independence condition is called <strong>full sequential exchangeability</strong>.</p>
<hr>
</section>
</section>
<section id="time-varying-confounders-push-this-to-later-section" class="level3">
<h3 class="anchored" data-anchor-id="time-varying-confounders-push-this-to-later-section">Time-Varying Confounders [Push this to later section]</h3>
<p>For both time-fixed and time-varying cases, we need to rely on expert knowledge to design studies and measure as many relevant covariates <span class="math inline">\(\bar{L}_k\)</span> to have more promising possibility of securing sequential exchangeability in observational studies. This is especially true when considering potential time-varying confounders that affect both treatment history <span class="math inline">\(\bar{A}\)</span> and the outcome <span class="math inline">\(Y\)</span> to not bias estimates on causal effects. While there is no way to empirically confirm that all confounders are measured, even in the case of correctly measuring and modeling all confounderes, most adjustments method may still result in biased estimates when comparing treatment strategies. Thus, <strong>g-methods</strong> are the appropriate approach to adjust for time-varying confounders.</p>
<section id="definition-of-time-varying-confounding" class="level4">
<h4 class="anchored" data-anchor-id="definition-of-time-varying-confounding">Definition of Time-Varying Confounding</h4>
<p>In the absence of selection bias, we say there is confounding for causal effects involving <span class="math inline">\(E[Y^{\bar{a}}]\)</span> if <span class="math inline">\(E[Y^{\bar{a}}]\neq E[Y|A=\bar{a}]\)</span> , meaning, consistency is not held, and all individuals in the study followed strategy <span class="math inline">\(\bar{a}\)</span> differs from the mean outcome among the subset of individuals who followed strategy <span class="math inline">\(\bar{a}\)</span> in the actual study. We say the <strong>confounding is solely time-fixed</strong> when, attributing to baseline covariates only, <span class="math inline">\(E[Y^{\bar{a}}|L_0] = E[Y|A=\bar{a}, L_0]\)</span>. If this does not hold i.e., <span class="math inline">\(E[Y^{\bar{a}}|L_0] \neq E[Y|A=\bar{a}, L_0]\)</span>, then we say that <strong>time-varying confounding is present</strong>. A sufficient condition for no time-varying confounding is unconditional sequential exchangeability <span class="math inline">\(Y^{\bar{a}}\perp A_k|\bar{A}_{k-1} = \bar{a}_{k-1}\)</span> i.e., SWIG only involving <span class="math inline">\(A_0\)</span>, <span class="math inline">\(A_1\)</span>, and <span class="math inline">\(Y\)</span>.</p>
<hr>
</section>
</section>
</section>
<section id="ch20-treatment-confounder-feedback" class="level2">
<h2 class="anchored" data-anchor-id="ch20-treatment-confounder-feedback">CH20: Treatment-Confounder Feedback</h2>
<ul>
<li><p>Structure of treatment-confounder feedback in time-varying treatment setting, and why tradtional adjustments methods for confounding fails with its presence.</p></li>
<li><p>Effort: &lt; 1 week</p></li>
</ul>
</section>
<section id="ch21-g-methods-for-time-varying-treatments" class="level2">
<h2 class="anchored" data-anchor-id="ch21-g-methods-for-time-varying-treatments">CH21: G-Methods for Time-Varying Treatments</h2>
<ul>
<li><p>Use of g-methods (g-formula, IPW, g-estimation, doubly-robust generalizations) to estimate causal effect of time-varying treatment under the presence of treatment-confounder feedback.</p></li>
<li><p>**This chapter is long, full of long equations. Be ready for a potential mash-up with the baseline method notations to save some time and space for note taking.</p></li>
<li><p>Effort: &lt; 3 weeks</p></li>
</ul>
</section>
<section id="ch22-target-trial-emulation" class="level2">
<h2 class="anchored" data-anchor-id="ch22-target-trial-emulation">CH22: Target-Trial Emulation</h2>
<ul>
<li><p>Target Trial: Observational data can be viewed as an attempt to emulate a hypothetical randomized trial.</p></li>
<li><p>This chapter generalizes the concept of the target trial to sustained treatment strategies and outlines a unified framework for causal inference, regardless of whether the data arose from a randomized experiment or an observational study.</p></li>
<li><p>It also describes a taxonomy of causal effects that may be of interest when emulating a target trial, including observational analogs of intention-to-treat and per-protocol effects. If data are available on all important fixed and time-varying confounders, the effects of interest can now be validly estimated.</p></li>
<li><p>Effort: 1.5 week</p></li>
</ul>
</section>
<section id="ch23-causal-mediation" class="level2">
<h2 class="anchored" data-anchor-id="ch23-causal-mediation">CH23: Causal Mediation</h2>
<ul>
<li><p>Causal mediation: The study of the causal pathways through which the treatment affects the outcome; mediation analysis involves the treatment of interest and the mediator at different times, opening empirical verification of the causal estimates.</p></li>
<li><p>Effort: &lt; 1 week</p></li>
</ul>
<hr>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="causal_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="288"></p>
</figure>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>